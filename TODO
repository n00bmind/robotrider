:::::::::::::::::::::::::::
:: robotrider TO-DO list ::
:::::::::::::::::::::::::::


NEXT
- Modify the room generation algorithm so it uses the clusters as the voxels in the algorithm, generating rooms for a chunk of clusters at a time (superclusters)
- Sample the isosurface for every cluster in the exterior of each room/hall created, with a different resolution depending on distance
- Create a little 'mesh LOD' system that keeps a cache of dynamic mesh LODs that are resampled when necessary according to distance
- Generate several of these 'superclusters' and connect neighbouring
- Decent RNG and determinism


WORLDGEN
- Space Volumes partitioning using BSP at various scale levels
- Procedural generation of some kind of infinite pipe-like world structure
- Unify all mesh pools and put them behind a ticket mutex so they can be shared by threads. Remember to _first_ do the mesh generation
  in the thread, then copying it to the mesh pool _afterwards_

EDITOR
- Hot reloading doesn't seem to work here? (was testing editor camera params)
- Entity selection mode and showing debug data about them
- Orbiting camera around selected entity (with progressive zoom)
- A nice way to get nicely distributed debug colors https://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/

GRAPHICS
- Frustum culling
- Decent chasing camera
- Start working on surfaces & lighting
- Edge detection shader
  From reddit: "If you have a deferred renderer and it can write triangle IDs to a texture, then you can render a wireframe
  by just doing a simple edge detect on the triangle ID texture. Google for "edge detection" and/or "Sobel filter" for details.
  The nice things about this are that (a) you get hidden surface removal for free; and (b) it's a fixed cost to render, no matter how much geometry you have."
  (http://williamchyr.com/2014/03/development-update-edge-detection/)

AUDIO
- Win32: switch WASAPI to callback mode to reduce buffer size and improve latency.
  This implies creating a separate dedicated thread that just blits audio to the output.
  The buffer strategy wouldn't change, the game would check how much space is available and
  would produce the appropriate amount of frames, and the blitter thread would simply blit said
  amount to the device.
  Refs:
  https://msdn.microsoft.com/en-us/library/windows/desktop/dd370875(v=vs.85).aspx
  https://msdn.microsoft.com/en-us/library/windows/desktop/dd370844(v=vs.85).aspx
  https://github.com/pauldotknopf/WindowsSDK7-Samples/blob/master/multimedia/audio/RenderExclusiveEventDriven/WASAPIRenderer.cpp

ASSETS
- Add a global Handle concept.
  A Handle is about locating resources at runtime, hence it's a glorified pointer. For a 64-bit Handle this could be something like:
  · 8 bit for the system allocator where the resource was allocated
  · 8 bit for various flags
  · 16 bit for a generation number
  · 32 bit for the allocator-dependent "index"
  This is of course only valid at runtime.
  For persistence, we could have a 2-way association between asset ids and Handles. We could simply exchange asset ids for allocator index when going to/coming from disk.

ENGINE
- Use the concept from https://github.com/antirez/sds to create a new CString class (btw start using class for these 'handled' datatypes?), but do it a bit better (and in C+)
  Add a pointer to that and an 'owned' flag to our read-only string so that:
  · Memory ownership is explicit
  · Null-termination and interoperability with C apis is handled better
- Add a separate arena per thread so we don't have to keep thinking where to put per-thread work memory
- Separate physics & input thread running at a high framerate
- Compare Fletcher against MurmurHash and maybe switch (https://github.com/aappleby/smhasher/wiki)

DEBUGGING
- Make sure out-of-frame counters are handled and shown correctly so we can properly profile multithreaded code
- Hot reloading seems to be broken for ImGui elements
- Memory stats for arenas and pools
- Profiler
- Live editable 'switches' data file (reloadable asset) that can overwrite generic game & platform variables
- Command completion & history navigation in the console
- Really dump game state to disk (asynchronously) and study how hard it would be to make it loadable across evolving game state revisions (this would need a proper serialization system)
- Add a command line switch & ingame command to load a recorded input block from disk
- Simple static analysis:
  - Detect usage of 'internal' functions outside of the file where they're defined (in case we wanna ever have non-Unity builds)
- Have a look at the ImGui plot libraries as a starting point for the profiler(s) UI

TESTING
- Basic data types
- Math library
- All multithreaded code! (queues, etc.)

MISC

